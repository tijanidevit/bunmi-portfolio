---
title: My Journey as a Computer Science Student üéâ
date: 2021-01-27
published: false
tags: ['Markdown','Releases']
canonical_url: false
description: "My journey as a computer science student has been adventurous, reason being that,  before I became a computer science student, I doubted many things about computer sciences. I then came to discover a lot of things concerning computer sciences which  made me want to know more then I began to  seeking for more knowledge about various aspects in computer science."
---

My journey as a computer science student has been adventurous, reason being that,  before I became a computer science student, I doubted many things about computer sciences. I then came to discover a lot of things concerning computer sciences which  made me want to know more then I began to  seeking for more knowledge about various aspects in computer science.

First, some notions about science.

Science is not just a body of knowledge (though that is an important part of it). It is also venturing into the unknown, and developing the idea within yourself about what it means to really know something, and to understand that knowing something doesn‚Äôt mean you know the truth. It means you have a pretty good idea of what the reality of what you are studying is like. You are able to create a description that somehow resembles the reality of what you‚Äôre studying to such a degree that you are able to make predictions about it, and those predictions can be confirmed within some boundaries that are either known, or can be discovered, and subsequently confirmed by others without the need to revise the model. Even then, what you have is not ‚Äúthe truth.‚Äù What you have might be a pretty good idea for the time being. As Richard Feynman said, in science you never really know if you are right. All you can be certain of is that you are wrong. Being wrong can be very valuable, because you can learn the limits of your common sense perceptions, and knowing that, direct your efforts towards what is more accurate, what is closer to reality.

The field of computing and computer science doesn‚Äôt have this perspective. It is not science. Most Computer science professors  used to admit this openly, but my understanding is CS professors these days aren‚Äôt even aware of this distinction anymore. In other words, they don‚Äôt know what science is, but they presume that what they practice is science. CS, as it‚Äôs taught, has some value, but what I hope to introduce people to here is the notion that after they have graduated with a CS degree, they are in kindergarten, or perhaps first grade. They have learned some basics about how to read and write, but they have not learned what is really powerful about that skill. I will share some knowledge I have gleaned as someone who has ventured as a beginner in this perspective.

The first thing to understand is that an undergraduate computer science education doesn‚Äôt tend to give you any notions about what computing is. It doesn‚Äôt explore models of computing, and in many cases, it doesn‚Äôt even present much in the way of different models of programming. It presents one model of computing (the Von Neumann model), but it doesn‚Äôt venture deeply into concepts of how the model works. It provides some descriptions of entities that are supposed to make it work, but it doesn‚Äôt tie them together so that you can see the relationships; see how the thing really works.

Science is about challenging and forming models of phenomena. A more powerful notion of computing is realized by understanding that the point of computer science is not about the application of computing to problems, but about creating, criticizing, and studying the strengths and weaknesses of different models of computing systems, and that programming is a means of modeling our ideas about them. In other words, programming languages and development environments can be used to model, explore, and test, and criticize our notions about different computing system models. It behooves the computer scientist to either choose an existing computing architecture represented by an existing language, or to create a new architecture, and a new language, that is suitable to what is being attempted, so that the focus can be maintained on what is being modeled, and testing that model without a lot of distraction.

